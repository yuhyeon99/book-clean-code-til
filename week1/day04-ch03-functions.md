# 3장. 함수

## **오늘 TIL 3줄 요약**

- 함수와 그 함수의 인수는 가능한 짧을수록 좋다
- 한 가지만 해라
- 부수 효과를 일으키지 마라!

## **TIL (Today I Learned) 날짜**

- 2025.05.26~2025.05.27

## **오늘 읽은 범위**

- 3장. 함수

## **책에서 기억하고 싶은 내용을 써보세요.**

### 작게 만들어라

- 함수를 만드는 첫째 규칙은 ‘작게 !’다.
    - 둘째 규칙은 ‘더 작게!’다.

### 한 가지만 해라!

> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.
> 
- 저자가 서술하는 **한 가지**란?
    1. 추상화 수준이 하나다.
    2. 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈.

### 함수당 추상화 수준은 하나로!

- 함수가 확실히 ‘한 가지’ 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다.
- 한 함수 내에 추상화 수준을 섞으면 코드를 읽는 사람이 헷갈린다.
    - 근본 개념과 세부사항을 뒤섞기 시작하면, 깨어진 창문처럼 사람들이 함수에 세부사항을 점점 더 추가한다.
- 위에서 아래로 코드 읽기: **내려가기** 규칙
    - 코드는 위에서 아래로 이야기처럼 읽혀야 좋다.
    - 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다.
    - 다르게 표현하면, **일련의 TO 문단을 읽듯이 프로그램이 읽혀야 한다는 의미**.
- 하지만 추상화 수준이 하나인 함수를 구현하기란 쉽지 않다.
    - 그렇지만 매우 중요한 규칙이다.
    - 핵심은 짧으면서도 ‘한 가지’만 하는 함수다.

### Switch 문

- switch 문은 작게 만들기 어렵다.
- 또한 ‘한 가지’ 작업만 하는 switch 문도 만들기 어렵다
- 하지만 **다형성**을 이용하여 각 switch 문을  저차원 클래스에 숨기고 절대로 반복하지 않는 방법이 있다.

### 서술적인 이름을 사용하라

- 길고 서술적인 이름이 짧고 어려운 이름보다 좋다.
- 서술적인 이름을 사용하면 개발자 머릿속에서도 설계가 뚜렷해지므로 코드를 개선하기 쉬워진다.
- 이름을 붙일 때는 일관성이 있어야 한다.
    - **include**SetupAndTeardownPages
    - **include**SetupPages
    - **include**SuiteSetupPage
    - **include**SetupPage
    - 등등

### 함수 인수

- 함수에서 이상적인 인수 개수는 0개(무항)다.
- **인수 객체**
    - 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어 본다.
        - ex)`Circle makeCircle(double x, double y, double radius)`
              `Circle makeCircle(Point center, double radius)`
- **동사와 키워드**
    - 함수와 인수가 동사/명사 쌍을 이뤄야 한다.
    - 함수 인수에 키워드를 추가하면 인수 순서를 기억할 필요가 없어진다
        - `assertEquals` ⇒ `assertExpectedEqualsActual(expected, actual)` 이 더 좋다.

### 플래그 인수

- **함수로 부울 값을 넘기는 관례는 정말로 끔찍하다.**
    - 왜냐하면 함수가 한꺼번에 여러 가지를 처리한다고 대놓고 공표하는 셈

### 부수 효과를 일으키지 마라!

- 부수 효과로 숨겨진 경우에는 더더욱 혼란이 커진다.
- 만약 시간적인 결합이 필요하다면 함수 이름에 분명히 명시한다.

### 명령과 조회를 분리하라

- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다.

### 오류 코드보다 예외를 사용하라!

- `if (deletePage(page) == E_OK)` 와 같은  코드는 동사/형용사 혼란을 일으키지 않는 대신 여러 단계로 중첩되는 코드를 야기한다.
- 반면 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 코드가 깔끔해진다.
    
    ```jsx
    try {
    	deletePage(page;
    	registry.deleteReference(page.name);
    	configKeys.deleteKey(page.name.makeKey());
    } catch (Exception e) {
    	logger.log(e.getMessage());
    }
    ```
    
- **Try/Catch 블록 뽑아내기**
    - try/catch 블록은 원래 추하다.
    - 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다.
    - 그러므로 try/catch 블록을 **별도 함수로 뽑아내는 편이 좋다.**
        
        ```jsx
        public void delete(Page page) {
        	try {
        		deletePageAndAllReferences(page);
        	} catch (Exception e) {
        		logError(e);
        	}
        }
        ```
        

### 반복하지 마라!

- 중복이 많아질수록 문제의 여지가 많아진다.
    - 코드 길이가 늘어남
    - 알고리즘이 변하면 여러 곳 손 봐야함.
    - 한 곳이라도 빠트리는 바람에 오류가 발생할 확률도 n배나 높다.

### 구조적 프로그래밍

- 함수는 return 문이 하나여야 한다.
- 함수를 작게 만든다면 간혹 return, break, continue를 여러 차례 사용해도 괜찮다.

### 함수를 어떻게 짜죠?

- 소프트웨어를 짜는 행위는 여느 글 짓기와 비슷하다.
- 초안은 대개 서투르고 어수선하므로 원하는 대로 읽힐 때까지 말을 다듬고 문장을 고치고 문단을 정리한다.

### 결론

- **진짜 목표는 시스템이라는 이야기를 풀어가는 데 있다는 사실을 명심하라**

## **오늘 읽은 소감은? 떠오르는 생각을 가볍게 적어보세요**

- clean code 함수 편에서는 한 가지 일을 하는게 중요하다는 점을 상기했다.
- 또한 깨끗한 코드보다 읽는 사람으로 하여금 헷갈릴 여지가 있는 코드를 작성하지 않는게 더 중요하다고 생각했다.

## **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**

## **오늘 읽은 다른사람의 TIL**

- rlagksalsq3님의 TIL: https://nomadcoders.co/community/thread/10483
