# 6장. 객체와 자료구조

## **오늘 TIL 3줄 요약**

- 구현을 감추려면 추상화가 필요하다!
- 절차적인 코드는 새로운 자료 구조를 추가하기 어렵고, 객체 지향 코드는 새로운 함수를 추가하기 어렵다.
- 분별 있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 알고 때로는 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황도 있다.

## **TIL (Today I Learned) 날짜**

- 2025.06.01

## **오늘 읽은 범위**

- 6장. 객체와 자료 구조

## **책에서 기억하고 싶은 내용을 써보세요.**

### 자료 추상화

- 변수 사이에 함수라는 계층을 넣는다고 구현이 저절로 감춰지지는 않는다.
- 구현을 감추려면 추상화가 필요하다.
    - **관련 예시**
        
        ## 📌 1. "변수 사이에 함수라는 계층을 넣는다"는 의미
        
        ```java
        public class Point {
            private double x;
            private double y;
        
            public double getX() { return x; }
            public double getY() { return y; }
        
            public void setX(double x) { this.x = x; }
            public void setY(double y) { this.y = y; }
        }
        ```
        
        - 이 클래스는 `x`, `y`를 `private`으로 바꾸고 대신 `get/set` 메서드를 사용했어요.
        - 즉, **함수를 한 겹 끼운 것**이죠.
        
        ### 👉 그런데 여전히…
        
        - 이 클래스가 "카르테시안 좌표를 사용한다"는 사실이 코드 밖에서도 드러남.
        - 외부는 여전히 `setX()`, `setY()`를 통해 **구현 방식에 직접 의존**함.
        
        > 🔴 즉, 함수로 감쌌지만 구현을 감춘 건 아님.
        > 
        > 
        > 구현을 바꾸면 외부 코드도 깨질 수 있음.
        > 
        
        ---
        
        ## ✅ 2. "구현을 감추려면 추상화가 필요하다"는 의미
        
        ```java
        public interface Point {
            double getX();
            double getY();
            void setCartesian(double x, double y);
            double getR();
            double getTheta();
            void setPolar(double r, double theta);
        }
        ```
        
        - 여기는 좌표계 방식이 뭔지 외부는 몰라요.
        - 어떤 클래스가 `x`, `y`로 저장하든, `r`, `θ`로 저장하든 **외부 입장에서는 알 필요가 없음.**
        - `Point`라는 **추상화(abstraction)**만 보고 사용하면 돼요.
        
        ### 👉 이렇게 해야 진짜 "구현을 감춘 것"
        
        - 내부 구조 바뀌어도 외부는 영향 없음.
        - `PolarPoint`, `CartesianPoint`처럼 다양한 구현체가 있어도 같은 방식으로 쓸 수 있음.
- 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다.
- 자료를 세세하게 공개하기보단 **추상적인 개념으로 표현하는 편이 좋다**.
    - 인터페이스나 조회/설정 함수만으로는 추상화가 이뤄지지 않는다.
    - 개발자는 객체가 포함하는 자료를 표현할 가장 좋은 방법을 심각하게 고민해야 한다.
- **하지만! 때로는 외부에서 개별 자료를 그대로 UI에 출력하거나 API 응답에 포함해야 할 때가 있다.**
    - 이 때 중요한건 **단순한 데이터 접근이 “로직 책임”을 외부에 떠넘기지 않도록 잘 제한하는 것**
        - 단순히 데이터에 접근해서 로직을 외부에서 진행한다면 추상화가 적절히 이루어지지 않은 것.

### 자료/객체 비대칭

- 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다.
- 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다.
- **절차적인 코드는 새로운 자료 구조를 추가하기 어렵다.**
- **객체 지향 코드는 새로운 함수를 추가하기 어렵다.**
- 분별 있는 프로그래머는 모든 것이 객체라는 생각이 미신임을 잘 안다.
    - **때로는 단순한 자료 구조와 절차적인 코드가 가장 적합한 상황도 있다.**

### 디미터 법칙

- 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙.
- 객체는 자료를 숨기고 함수를 공개한다.
- 객체는 조회 함수로 내부 구조를 공개하면 안 된다는 의미다.
- 그러면 내부 구조를(숨기지 않고) 노출하는 셈

### 자료 전달 객체

- 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스이다.
- 이런 자료 구조체를 때로는 자료 전달 객체(Data Transfer Object, DTO)라 한다.
- 데이터베이스와 통신하거나 소켓에서 받은 메세지의 구문을 분석할 때 유용함.
    - 흔히 DTO는 데이터베이스에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 일련의 단계에서 가장 처음으로 사용하는 구조체이다.
- 좀 더 일반적인 형태는 ‘빈bean’구조.

### 활성 레코드

- 활성 레코드는 DTO의 특수한 형태다.
- 불행히도 활성 레코드에 비즈니스 규칙 메서드를 추가해 이런 자료 구조를 객체로 취급하는 개발자가 흔하지만 **이는 바람직하지 않다**.
- 해결책은 활성 레코드는 자료 구조로 취급하고
    - 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다.

### 결론

- 객체는 동작을 공개하고 자료를 숨긴다.
    - 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다.(객체마다 메서드를 수정해줘야함..)
- 기존 자료 구조에 새 동작을 추가하기 쉬우나
    - 기존 함수에 새 자료 구조를 추가하기는 어렵다.(메서드마다 새로 들어온 객체를 반영해줘야함..)

## **궁금한 내용이 있거나, 잘 이해되지 않는 내용이 있다면 적어보세요.**

## **오늘 읽은 다른사람의 TIL**

- suhyeon1740님의 TIL: https://nomadcoders.co/community/thread/10526
